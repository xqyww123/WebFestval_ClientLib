/* I do not know what to write here...
 * So leave it blank~!
 * Write by Xero Essential!~
 *
 * */
#include <cstdio>
#include <climits>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <string>
#include <cstring>
#include <unordered_set>
#include <array>
#define CURRENT_ROUND -1
#define LAST_ROUND -2
#define NEXT_ROUND -3
#define CARD_NUM 104
#define FIRST_ROUND 1
#define BEFORE_GAME_START_ROUND 0
#define CARD_UNKNOWN -1
#define CARD_DROPED -2
using namespace std;
typedef int Card;
typedef int AgentIndex;
typedef int Cluster;

class Agent
{
	Card card_decision;
    Cluster eat_decision;
	void ClearLastDecision();
	
	vector<string> players;
	vector<unordered_set<Card> > mycards;
	vector<int> droped_cards;
	vector<array<vector<int>, 4> > cards;
	vector<vector<int> > showed_cards;
	vector<int> whoeat;
	vector<int> eatwhich;
	array<int, CARD_NUM+1> whouse;
	vector<int> scores;
	int curi, myindex;
	static int score_table[CARD_NUM+1];
	static void InitScoreTable();

	void Init();
protected:
	Agent() { InitScoreTable(); }
	int trans_index(int round_index) ;
	int CalcuScore(vector<Card>& cards);
	int CalcuScore(Cluster cluster) { return CalcuScore(Cards()[cluster]); }
	int GetScore(Card);
public:

	// please override this function and return your contest id;
	virtual const string GetMyId() const = 0;
	int GetMyIndex() { return myindex; }

	vector<string>& GetPlayers() { return players; }
	int PlayerCount() { return players.size(); }

	int CurrentTurnIndex() { return curi; }
	//return val : an array of 4 elements for each cluster, means the cards in specified round.
	array<vector<Card>, 4> Cards(int round_index = CURRENT_ROUND) { return cards[trans_index(round_index)]; }
	// means the cards in your hand in specified round.
	unordered_set<Card> MyCards(int round_index = CURRENT_ROUND) { return mycards[trans_index(round_index)]; }
	// an array of PlayCount elements for each agent's showed card in specified round
	vector<int> UsedCard(int round_index = LAST_ROUND) { return showed_cards[trans_index(round_index)]; }
	AgentIndex WhoEate(int round_index = LAST_ROUND) { return whoeat[trans_index(round_index)]; }
	Cluster EateWhich(int round_index = LAST_ROUND) { return eatwhich[trans_index(round_index)]; }
	vector<AgentIndex> Scores() { return scores; }

	// some card may droped before game start
	vector<Card>& DropedCrads() 
		{ return droped_cards; }
	// a vector shows each card was used by who
	// -1 means unknown
	// -2 means this card is droped.
	// length : CARD_NUM
	array<int, CARD_NUM+1> WhoUse() { return whouse; }


	// decide the card to use in current turn.
	void DecideCard(Card card) {  card_decision = card; }
	// decide the cluster to eat.
	void DecideEat(Cluster cluster_index) { eat_decision = cluster_index; }

	virtual void OnGameStart();
	virtual void OnRoundStart(int round_index);
	// In this process : please make your decision with DecideCard function.
	// If your didn't call DecideCard function, the program will throw an exception.
	// The latest call of DecideCard fucntion will be adopt for the multiple calls.
	virtual void OnMyTurn(int round_index) = 0;
	// please call DecideEat function before the OnEatCluster process end.
	// you could call DecideEat in either OnEatCluster fucntion or any other place such as OnRoundStart function
	// ( It's your right to consider the bad situation early, of course. )
	// But if you forget to call DecideEat function, an exception will be throwed.
	// The latest call of DecideEat fucntion will be adopt for the multiple calls.
	virtual void OnEatCluster(int round_index) = 0;
	virtual void OnRoundEnd(int round_index);
	virtual void OnGameEnd();

	void Run();
}; 

int Agent::score_table[CARD_NUM+1];

void Agent::ClearLastDecision()
{
	card_decision = eat_decision = -1;
}

char scan_buf[256];
void Agent::Init()
{
	whoeat.clear();
	whoeat.push_back(-1);
	eatwhich.clear();
	eatwhich.push_back(-1);
	showed_cards.clear();
	showed_cards.push_back(vector<int>());
	whouse.fill(-1);
	scores.clear();

	printf("%s\n", GetMyId().c_str());
	curi = 0;
	int n, m, p, a, b, c;
	scanf("%d%d%d", &n, &m, &p);
	players.clear();
	for (int i=0;i<n;++i)
	{
		scanf("%s", scan_buf);
		players.push_back(string(scan_buf));
	}
	myindex = PlayerCount();
	scores.resize(PlayerCount());
	mycards.clear();
	mycards.push_back(unordered_set<int>());
	for (int i=0;i<m;++i)
	{ scanf("%d", &a); mycards[0].insert(a); }
	for (int i=0;i<p;++i)
	{ scanf("%d", &a); droped_cards.push_back(a); whouse[a] = CARD_DROPED; }
	cards.clear();
	for (int i=0;i<4;++i)
	{ 
		cards.push_back(array<vector<int>, 4>()) ;
		for (int j=0;j<4;++j)
		{
			scanf("%d", &a);
			cards[0][j].push_back(a);
		}
	}

}

void Agent::Run()
{
	Init();
	OnGameStart();
	int a,b,c;
	int* inp = new int[PlayerCount()];
	while (true)
	{
		ClearLastDecision();
		OnRoundStart(curi);
		OnMyTurn(curi);
		if (card_decision == -1)
			throw "ERR01 You forget make card decision";
		printf("%d\n", card_decision);
		UsedCard()[myindex] = card_decision;
		WhoUse()[card_decision] = myindex;
		for (int i=0;i<PlayerCount();++i)
		{ 
			scanf("%d", inp + i); 
			UsedCard()[]
	   	}
		cards.push_back(array<vector<int>, 4>());
		for (int i=0;i<4;++i) Cards(NEXT_ROUND)[i] = Cards()[i];
		for (int i=0;i<PlayerCount();++i)
		{
			int vmin = INT_MAX, vmi;
			for (int j=0;j<PlayerCount();++j)
				if (vmin > inp[j])
				{ vmin = inp[j]; vmi = j; }
			inp[vmi] = INT_MAX;
			int ci, cv = -1;
			for (int j=0;j<4;++j)
			{
				if (Cards()[j].back() > vmin && Cards()[j].back() > cv )
				{ cv = Cards()[j].back(); ci = j; }
			}
			if (cv == -1)
			{
				int eat;
				if (vmi == myindex)
				{
					OnEatCluster(curi);
					if (eat_decision == -1)
						throw "ERR02 You forget make eat decision!";
					printf("%d\n", eat = eat_decision);
				}
				else { scanf("%d", &eat); }
				scores[vmi] += CalcuScore(eat);
				Cards(NEXT_ROUND)[eat].clear();
				continue;
			}
			if (Cards()[ci].size() == 5)
			{
				scores[vmi] += CalcuScore(ci);
				Cards(NEXT_ROUND)[ci].clear();
			}
			else Cards(NEXT_ROUND)[ci].push_back(vmin);
		}

		OnRoundEnd(curi);
		curi ++;
	}
	OnGameEnd();
	delete[] inp;
}

int Agent::trans_index(int round_index) 
{
	switch(round_index)
	{
		case CURRENT_ROUND:
			return curi;
		case LAST_ROUND:
			return curi-1;
		case NEXT_ROUND:
			return curi+1;
		default:
			return round_index;	
	}
}

void Agent::InitScoreTable()
{
	if (Agent::score_table[0]) return;
	for (int i=0;i<CARD_NUM+1;++i) 
	{
		Agent::score_table[i] = 1;
		if (!(i%5)) Agent::score_table[i] = 2;
		if (!(i%10)) Agent::score_table[i] = 3;
		if (!(i%11)) Agent::score_table[i] = 5;
	}
	Agent::score_table[55] = 7;
}
int Agent::GetScore(Card card)
{
	return Agent::score_table[card];
}
int Agent::CalcuScore(vector<Card>& cards)
{
	int re = 0;
	for (auto a : cards)
		re += GetScore(a);
	return re;
}
